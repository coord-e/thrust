// vim: set ft=rust :

// f: (<int, int>, int) -> int
// ({ &mut int | p0 ν }, { int | p1 $0 ν }) → { int | p2 $1 $0 ν }
fn f(_1: &mut i32, _2: i32) -> i32 {
    debug x => _1;
    debug y => _2;
    let mut _0: i32;

    // in: {_1, _2}
    // ({ &mut int | p3 ν }, { int | p4 $0 ν }) → { int | p5 $0 $1 ν }
    bb0: {
        // tmp_vars: TempVar => RefinedType<Var>
        //   t1: int
        //   t2: int
        // locals: Local => RefinedType<Var>
        //   _2: { int | p4 $0 ν }
        // assumptions: chc::Atom<Var>
        //   p3 <_1*, _1^>
        // mut_locals: Local => MutLocalBinding
        //   _1: <_1*, _1^>

        // { () | °<_1*, _1^>  = _2 }
        (*_1) = _2;
        _0 = const 1_i32;
        return;
    }
}

// main: () -> ()
fn main() -> () {
    let mut _0: ();
    let mut _1: i32;
    let _3: i32;
    let mut _4: i32;
    let mut _5: !;
    scope 1 {
        debug a => _1;
        let _2: &mut i32;
        scope 2 {
            debug m => _2;
        }
    }

    // in: {_0}
    // ({ () | pbb0_0 _0 }) -> ()
    bb0: {
        // vars: {}
        // elaborate _1: mut i32 => _1: box i32
        //   template for _1: { <int> | p1 _0 }
        //   rvalue refty: { int | _0 = 1 }
        //   (elaborated) subtype results in c0: p1 _0 <= _0.0 = 1
        // env.bind(_1: { <int> | p1 _0 })
        //   => vars: _1: <_1'>, _1': { int | p1 <_0> }
        _1 = const 1_i32;
        // template for _2: { <int, int> | p2 _0 _1' }
        // rvalue refty: { <int, int> | _0 = <_1', ph0> }
        //   env.mut_borrow(_1)
        //     => vars: _1: <f0>, _1': { int | p1 <_0> }, phs: ph0: int
        // subtype results in c1: p2 _0 _1' <= _0 = <_1', ph0>
        // env.bind(_2: { <int, int> | p2 _0 _1' })
        //   => vars: _1: <f0>, _1': { int | p1 <_0> }, _2: <_2', _2^>, p2 <_2', _2^> _1'
        _2 = &mut _1;
        _3 = f(_2, const 2_i32) -> [return: bb1, unwind continue];
        // bb1(_1, _2, _3)
    }

    // in: {_0, _1}
    // ({ () | pbb1_0 _0 _2 }, { own int | pbb1_1 _0 _1 }) -> ()
    bb1: {
        _4 = _1;
        switchInt(move _4) -> [2: bb2, otherwise: bb3];
    }

    // in: {_0}
    bb2: {
        return;
    }

    // in: {}
    bb3: {
        _5 = core::panicking::panic(const "assertion failed: a == 2") -> unwind continue;
    }
}
